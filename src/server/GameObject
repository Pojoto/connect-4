local Sequence = require(game:GetService("ServerScriptService").Sequence)
local ProfileManager = require(game:GetService("ServerScriptService").ProfileStuff.ProfileManager)
local ItemData = require(game:GetService("ServerScriptService").ItemData)

local turn_remote = game:GetService("ReplicatedStorage").Turn

local GameObject = {}

GameObject.__index = GameObject


function GameObject.new(player1, player2, unit)
	local newGame = {}
	setmetatable(newGame, GameObject)
	
	--this gives us the name of the token skin equipped, now we use item data to fetch its color property
	local equip_key1 = ProfileManager:Get(player1, "Equipped").TokenSkin
	--check to see if the player has default skin equipped
	local color1
	if equip_key1 == "DefaultColor" then
		color1 = ItemData:get_item_data(equip_key1).Color[1]
	else
		color1 = ItemData:get_item_data(equip_key1).Color
	end
	local material1 = ItemData:get_item_data(equip_key1).Material
	local player1_info = {player1, {Color = color1, Material = material1}}
	
	
	local equip_key2 = ProfileManager:Get(player2, "Equipped").TokenSkin
	local color2
	--check if default but also check if playre2 has same skin as player1. if they do then go to default
	if equip_key2 == "DefaultColor" or equip_key2 == equip_key1 then
		equip_key2 = "DefaultColor"
		color2 = ItemData:get_item_data(equip_key2).Color[2]
	else
		color2 = ItemData:get_item_data(equip_key2).Color
	end
	local material2 = ItemData:get_item_data(equip_key2).Material
	local player2_info = {player2, {Color = color2, Material = material2}}
	
	newGame.Players = {player1_info, player2_info}
	newGame.BoardMatrix = {
		{},
		{},
		{},
		{},
		{},
		{},
		{}
	}
	newGame.Unit = unit
	newGame.TokenMatrix = {
		{},
		{},
		{},
		{},
		{},
		{},
		{}
	}
	newGame.CurrentTurn = 1
	
	return newGame
end


function GameObject:NextTurn(id)
	
	--add delay between turns
	wait(0.5)
	
	turn_remote:FireClient(self.Players[self.CurrentTurn][1], id, self)
end

function GameObject:IsGameOver(drop_column)
	local board = self.BoardMatrix
	local drop_row = #board[drop_column]
	
	--if the dropped column is full
	if drop_row == 6 then
		local spaces = 0
		--check if all spaces are occupied - if it is then game over
		for i = 1, #board do
			spaces += #board[i]
		end
		if spaces >= 42 then
			return true, nil, nil
		end
	end

	local sequences, diag_drop_indices = Sequence.get_sequences(board, drop_row, drop_column)

	for i, sequence in ipairs(sequences) do
		local is_four_in_a_row, winner_turn, start_index = Sequence.check_four_in_a_row(sequence)
		if is_four_in_a_row then
			
			--make winning 4 in a row tokens green
			local second_indices, first_indices = Sequence.find_four(drop_row, drop_column, i, start_index, diag_drop_indices)
		
			--delay to let user see board before lighting green
			wait(1.5)			
			
			for i = 1, 4 do
				local token = self.TokenMatrix[first_indices[i]][second_indices[i]]
				token.Color = Color3.new(0.235294, 1, 0)
				token.Material = Enum.Material.Neon
				wait(0.05)
			end
			
			return true, self.Players[winner_turn][1], self.Players[winner_turn % 2 + 1][1]
		end
	end

	return false, nil, nil
end

function GameObject:Destroy()
	self.Unit:Destroy()
	self.BoardMatrix = nil
	self.Players = nil
end

return GameObject

--players get in a queue

--once 2 players in queue

--make new game object with those 2 players as parameters

--board matrix is a variable

--have methods to call a player turn whcih will send a remote event to the player

--player sends reote event back signaling end of their return
	
--	main script to catch these client calls

--game object also passed as a paramaeter whenever a remote event is called


--when server catches client call, it takes the game object passed and calls the next turn of the next player

--this is done after checking if the board state is finished or not
