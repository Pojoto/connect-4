local Sequence = require(game:GetService("ServerScriptService").Sequence)

local turn_remote = game:GetService("ReplicatedStorage").Turn

local GameObject = {}

GameObject.__index = GameObject


function GameObject.new(player1, player2, unit)
	local newGame = {}
	setmetatable(newGame, GameObject)
	
	local player1_info = {player1, Color3.new(1, 0, 0)}
	local player2_info = {player2, Color3.new(1, 1, 0)}
	
	newGame.Players = {player1_info, player2_info}
	newGame.BoardMatrix = {
		{},
		{},
		{},
		{},
		{},
		{},
		{}
	}
	newGame.Unit = unit
	newGame.CurrentTurn = 1
	
	return newGame
end


function GameObject:NextTurn(id)
	
	--add delay between turns
	wait(0.5)
	
	turn_remote:FireClient(self.Players[self.CurrentTurn][1], id, self)
end

function GameObject:IsGameOver(drop_column)
	local board = self.BoardMatrix
	local drop_row = #board[drop_column]
	
	--if the dropped column is full
	if drop_row == 6 then
		local spaces = 0
		--check if all spaces are occupied - if it is then game over
		for i = 1, #board do
			spaces += #board[i]
		end
		if spaces == 42 then
			return true, nil, nil
		end
	end

	local sequences = Sequence.get_sequences(board, drop_row, drop_column)

	for i, sequence in ipairs(sequences) do
		local is_four_in_a_row, winner_turn = Sequence.check_four_in_a_row(sequence)
		if is_four_in_a_row then
			return true, self.Players[winner_turn][1], self.Players[winner_turn % 2 + 1][1]
		end
	end

	return false, nil, nil
end

function GameObject:Destroy()
	self.Unit:Destroy()
	self.BoardMatrix = nil
	self.Players = nil
end

return GameObject

--players get in a queue

--once 2 players in queue

--make new game object with those 2 players as parameters

--board matrix is a variable

--have methods to call a player turn whcih will send a remote event to the player

--player sends reote event back signaling end of their return
	
--	main script to catch these client calls

--game object also passed as a paramaeter whenever a remote event is called


--when server catches client call, it takes the game object passed and calls the next turn of the next player

--this is done after checking if the board state is finished or not
