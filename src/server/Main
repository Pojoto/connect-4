
local play_human_remote = game:GetService("ReplicatedStorage").PlayHuman
local play_self_remote = game:GetService("ReplicatedStorage").PlaySelf
local turn_remote = game:GetService("ReplicatedStorage").Turn
local camera_remote = game:GetService("ReplicatedStorage").Camera
local game_over_remote = game:GetService("ReplicatedStorage").GameOver
local player_state_remote = game:GetService("ReplicatedStorage").PlayerState

local GameObject = require(game:GetService("ServerScriptService").GameObject)
local unit = game:GetService("ServerStorage").Unit
local token = game:GetService("ReplicatedStorage").Token

local SPACING = 8
local HEIGHT = 25

local columns_x = {

	-3 * SPACING,
	-2 * SPACING,
	-SPACING,
	0,
	SPACING,
	2 * SPACING,
	3 * SPACING

}

local iteration = 0
local board_dict = {}

--contians the player of the next person to be paired to a game
local queue = nil


local function drop_token(center, drop_column, color)
	local clone = token:Clone()
	clone.Position = Vector3.new(center.Position.X -  columns_x[drop_column], center.Position.Y + HEIGHT, center.Position.Z) 
	clone.Color = color
	clone.Anchored = false
	clone.Parent = game.Workspace
end

local function get_sequences(board, drop_row, drop_column)
	
	local row = {}
		
	for i = 1, #board do
		--if there is an empty space in the row, we still need to add something to the row or else the gap disappears,
		--this can result in xxx_x being counted as four in a row. 0 does not match with any other so it's guarnateed not to be 4 ina  row
		local to_insert = if board[i][drop_row] then board[i][drop_row] else 0
		table.insert(row, to_insert)
	end
	
	local col = board[drop_column]
	
	--diagonal initially contains the current token (token just dropped)
	local incline_diag = {board[drop_column][drop_row]}
	
	--back and front go search opposite directions in the diagonal
	local i = 1
	--this statement returns nil if the first indexed chunk is nil. if it's not nil then it will continue and return the next indexed chunk.
	--this prevents a 'index nil with' error
	local back = if board[drop_column - i] then board[drop_column - i][drop_row - i] else nil
	local front = if board[drop_column + i] then board[drop_column + i][drop_row + i] else nil
	
	while back or front do
		if back then
			table.insert(incline_diag, 1, back)
			back = if board[drop_column - i - 1] then board[drop_column - i - 1][drop_row - i - 1] else nil
		end
		
		if front then
			table.insert(incline_diag, front) 
			front = if board[drop_column + i + 1] then board[drop_column + i + 1][drop_row + i + 1] else nil
		end
		
		i += 1
	end
	
	local decline_diag = {board[drop_column][drop_row]}
	i = 1
	back = if board[drop_column - i] then board[drop_column - i][drop_row + i] else nil
	front = if board[drop_column + i] then board[drop_column + i][drop_row - i] else nil
	
	while back or front do
		if back then
			table.insert(decline_diag, 1, back)
			back = if board[drop_column - i - 1] then board[drop_column - i - 1][drop_row + i + 1] else nil
		end

		if front then
			table.insert(decline_diag, front) 
			front = if board[drop_column + i + 1] then board[drop_column + i + 1][drop_row - i - 1] else nil
		end

		i += 1
	end
	
	return {row, col, incline_diag, decline_diag}
	
end

local function is_four_in_a_row(sequence)
	for i = 1, #sequence do
		for j = i + 1, #sequence do
			if sequence[j] == 0 or sequence[i] ~= sequence[j] then
				break
			end
			if j - i == 3 then
				return true, sequence[j]
			end
		end
	end
	return false, nil
end

local function is_game_over(board, drop_column)
	local drop_row = #board[drop_column]
	
	if drop_row == 6 then
		local spaces = 0
		--check if all spaces are occupied - if it is then game over
		for i = 1, #board do
			spaces += #board[i]
		end
		if spaces == 42 then
			return true, nil
		end
	end
	
	local sequences = get_sequences(board, drop_row, drop_column)
	
	for i, sequence in ipairs(sequences) do
		local connection, winner = is_four_in_a_row(sequence)
		if connection then
			return true, winner
		end
	end
	
	return false, nil
	
end

play_human_remote.OnServerEvent:Connect(function(player)
	
	if queue then --check if queue is empty
		
		--check for same player entering queue
		if queue ~= player then
	
			local new_unit = unit:Clone()
			
			new_unit.Parent = game.Workspace
			new_unit:PivotTo(CFrame.new(new_unit.PrimaryPart.Position + Vector3.new(0, 0, 200 * iteration)))
			
			local center = new_unit.Board.Center
			
			--change players states to game state - updates ui and camera
			player_state_remote:FireClient(queue, "game", center, player)
			player_state_remote:FireClient(player, "game", center, queue)
		
			local new_game = GameObject.new(queue, player, new_unit)
			queue = nil

			--make a new id (simple linearish function helps provide some concealment so exploiters can't send random ids of other games)
			local new_id = 2 * iteration + (iteration % 4 + 92)

			iteration += 1
			
			--add the game object and its id to the database
			board_dict[new_id] = new_game

			new_game:NextTurn(new_id, center, new_game.BoardMatrix)
		end
		
	else --if queue is empty
		queue = player
		player_state_remote:FireClient(player, "in queue", true)
	end
end)

play_self_remote.OnServerEvent:Connect(function(player)
	local new_unit = unit:Clone()
	new_unit.Parent = game.Workspace
	new_unit:PivotTo(CFrame.new(new_unit.PrimaryPart.Position + Vector3.new(0, 0, 200 * iteration)))

	local center = new_unit.Board.Center
	
	--check if the player is in the queue. if they are then remove them from queue
	if queue == player then
		queue = nil
	end

	--fire clients to hide intro frame and to move camera into unit
	player_state_remote:FireClient(player, "game", center, player)

	local new_game = GameObject.new(player, player, new_unit)
	
	local new_id = 2 * iteration + (iteration % 4 + 92)
	iteration += 1
	board_dict[new_id] = new_game
	
	new_game:NextTurn(new_id, center, new_game.BoardMatrix)
end)

turn_remote.OnServerEvent:Connect(function(player, id, drop_column)
	
	--find the players associated game object through its given id
	local game_object = board_dict[id]
	
	--find the center associated with the unit of the game object
	local center = game_object.Unit.PrimaryPart
	
	--execute the turn in the board matrix and physically(server side)
	table.insert(game_object.BoardMatrix[drop_column], game_object.CurrentTurn)
	drop_token(center, drop_column, game_object.Players[game_object.CurrentTurn][2])
	
	local finished, winner_turn = is_game_over(game_object.BoardMatrix, drop_column)
		
	if finished then
		--the game is over (connect 4 found)
		wait(1)
		--check if game was tie (if turn was returned nil)
		if winner_turn then
			--fire client to winner that he won, fire client to loser that he lost
			player_state_remote:FireClient(game_object.Players[winner_turn % 2 + 1][1], "game over", false)
			player_state_remote:FireClient(game_object.Players[winner_turn][1], "game over", true)
		else
			player_state_remote:FireClient(game_object.Players[winner_turn % 2 + 1][1], "game over", nil)
			player_state_remote:FireClient(game_object.Players[winner_turn][1], "game over", nil)
		end
		wait(2)
		game_object:Destroy()
		
	else
		--check if someone won, if they didnt then call next turn
		game_object.CurrentTurn = (game_object.CurrentTurn % 2) + 1

		wait(0.5)

		--call the next player's turn
		game_object:NextTurn(id, center, game_object.BoardMatrix)
	end
	


end)

